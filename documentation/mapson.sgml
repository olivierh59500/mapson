<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
<!ENTITY mapson "<application>mapSoN</application>">
<!ENTITY description SYSTEM "description.inc">
<!ENTITY building SYSTEM "building.inc">
<!ENTITY synopsis SYSTEM "synopsis.inc">
<!ENTITY cmdloptions SYSTEM "cmdloptions.inc">
<!ENTITY configfile SYSTEM "configfile.inc">
<!ENTITY license SYSTEM "license.inc">
<!ENTITY defconfig SYSTEM "defconfig.inc">
<!ENTITY defreqmail SYSTEM "defreqmail.inc">
<!ENTITY version SYSTEM "../VERSION">
]>

<article lang="en">
  <articleinfo>
    <title>&mapson; &version; User Manual</title>
    <author>
      <firstname>Peter</firstname>
      <surname>Simons</surname>
      <affiliation>
        <address><email>simons@computer.org</email></address>
      </affiliation>
    </author>
  </articleinfo>

  <sect1>
    <title>Introduction</title>

    &description;

  <para>This illustration will probably help not all and only add to the
confusion, but I made it, and now I have to include it here -- helpful or
not!</para>

  <mediaobject>
    <imageobject>
      <imagedata fileref="principle1.eps" format="eps" align="center" scale="40">
    </imageobject>
    <imageobject>
      <imagedata fileref="principle1.png" format="png" align="center">
    </imageobject>
  </mediaobject>
  <mediaobject>
    <imageobject>
      <imagedata fileref="principle2.eps" format="eps" align="center" scale="40">
    </imageobject>
    <imageobject>
      <imagedata fileref="principle2.png" format="png" align="center">
    </imageobject>
  </mediaobject>

  <sect1>
    <title>Building &mapson;</title>
    &building;
  </sect1>

  <sect1>
    <title>How to Activate &mapson;</title>

    <para>Assuming, you have built and installed the &mapson; package
sucessfully, you must do two things to activate it: Create the directory
<quote><filename>.mapson</filename></quote> in your home directory and tell your
Mail Transport Agent to pipe incoming local mail into &mapson; rather than to
deliver it to the mailbox directly.</para>

    <para>The first step should be manageable without further instructions, but
installing &mapson; as local mailer is non-trivial. The rest of this chapter is
divided into separate sections that will describe the various possible setups.
How &mapson; must be installed depends entirely on the Mail Transport Agent you
use, so if your configuration is not discussed in this manual, please consult
your MTA's user manual instead. And if you found out how to do it, please write
a short paragraph about it and let me know so that I can include it in the next
version!</para>

    <sect2>
      <title>Using <application>sendmail</application>'s
<filename>.forward</filename> mechanism</title>

      <para>Before I start, let me give you one piece of advice: Using &mapson;
without any further tool installed that will allow you to filter and to redirect
incoming mail into different folders will <emphasis>not</emphasis> make you
happy. This kind of installation is nice to figure out whether &mapson; is
useful to you, but you <emphasis>should</emphasis> install
<application>procmail</application> or a similar program as soon as possible.
Trust me.</para>

      <para>Anyway, <ulink
url="http://www.sendmail.org/"><application>sendmail</application></ulink> uses
a simple mechanism to forward incoming local mail into application programs: A
file named <filename>.forward</filename>, that must be located in your home
directory. To activate &mapson;, all you have to do is to create that file and
put the following line into it:</para>

      <informalexample>
        <screen>"|exec <replaceable>/usr/local/bin/mapson</replaceable>"</screen>
      </informalexample>

      <para>Apparently, on some systems the home directory must grant
execute-permission to "other" for the <application>sendmail</application> to
evaluate that file. So if you created the <filename>.forward</filename> file as
shown above and still there's no sign of any &mapson; activity, execute
<userinput>chmod 711 $HOME</userinput> and try again.</para>

      <para>Another potential obstacle is that some
<application>sendmail</application> installations use the restricted shell
(<acronym>smrsh</acronym>) for the execution of the local mailer. This shell
will not allow users to execute arbitrary commands in the
<filename>.forward</filename> file. If your system uses
<acronym>smrsh</acronym>, you must create a link from
<filename>/usr/local/bin/mapson</filename> to
<filename>/usr/adm/sm.bin/mapson</filename> in order to enable &mapson;. (The
paths may vary from system to system, obviously.)</para>
    </sect2>

    <sect2>
      <title>Using <application>procmail</application></title>

      <para>Most systems these days use <ulink
url="http://www.procmail.org/"><application>procmail</application></ulink> to
deliver local mail. This means, that you can configure your local mailer by
adding cryptic recipes in an entirely undocumented syntax to the file
<filename>.procmailrc</filename> in your home directory:</para>

      <informalexample>
        <screen># Have mapSoN accept anything that is a reply to a
# message of mine.
#
:0 w
* ^(In-Reply-To|References|Message-Id):.*<replaceable>example.com</replaceable>
| <replaceable>/usr/local/bin/mapson</replaceable> --accept

# Pipe anything that does not  come from a mailing
# list, into mapson for approval.
#
:0 w
* !^Precedence: (list|bulk|junk)
* !^Auto-Submitted:
| <replaceable>/usr/local/bin/mapson</replaceable></screen>
      </informalexample>

      <para>The first recipe will try to recognize mails that are a direct reply
to a mail or a news posting of yours. Such mails will have the
<literal>References</literal> or <literal>In-Reference-To</literal> headers set
to the original <literal>Message-Id</literal>, and because
<literal>Message-Id</literal>s contain your hostname, you can use that to make

**TODO**
&mapson; always accept those mails
recipe to have those mails be delivered to you without having to pass
&mapson;:</para>

      <informalexample>
        <screen># Have anything that is a reply to a message of mine
# accepted by mapSoN.
#
:0 w
* ^(In-Reply-To|References|Message-Id):.*<replaceable>example.com</replaceable>
| <replaceable>/usr/local/bin/mapson</replaceable> --accept</screen>
      </informalexample>

      <para>The <option>--accept</option> flag on the command line will tell
&mapson; to accept those mails and to add the sender's address to the database,
so that any new conversition with him will be accepted, too. Don't forget to
replace the <quote>example.com</quote> with your actual domain name for this to
work! Also, make sure that this recipe comes before<emphasis></emphasis> the
other one!</para>

      <para>One more thing that you will have to take care of is mails that are
being sent to you via a mailing list. Since you subscribed to that list, you
cannot possible expect people to confirm any postings that reach you via that
list. So you must use <application>procmail</application> to pass those postings
around &mapson; completely:</para>

      <informalexample>
        <screen># Mailing lists may always pass.
:0 w
* !^Precedence: (list|bulk|junk)
* !^Auto-Submitted:
$DEFAULT</screen>
      </informalexample>

<para>You can do it the other way round and modify the recipe we showed first to
exclude those mails!</para>

      <para>Because all this is probably confusing, here's the full recipe code
at one glance:</para>


      <sect3>
        <title><application>Procmail</application>'s Argument Feature</title>

      <para>Using <application>procmail</application>`s <quote>argument</quote>
feature, you can make this work even better. The idea is that an address of the
format <quote>user+parameter@example.com</quote> will still be delivered to the
<quote>user</quote>, but the string <quote>parameter</quote> will be availabe in
the <filename>.procmailrc</filename> config as an argument, which you can use to
sort the mail into a different folder. Look at this:</para>

      <informalexample>
        <screen>ARGUMENT="$1"

# An argument of 'pass' will always by-pass all other
# rules to make sure that I have a reliably working address
# no matter what happens here.
#
:0
* ARGUMENT ?? pass
$DEFAULT

# Confirmation mails go into mapSoN.
#
:0
* ARGUMENT ?? [a-f0-9]...repeat 32 times...[a-f0-9]
| <replaceable>/usr/local/bin/mapson</replaceable>
:0 ec

# Anything else that has such an argument is probably coming
# from a mailing list and should not go through mapSoN.
#
:0
* ARGUMENT ?? ..*
$DEFAULT

# Pipe anything, that is not a reply or comes from a mailing
# list, into mapson for approval.
#
:0 w
* !^(In-Reply-To|References|Message-Id):.*<replaceable>example.com</replaceable>
* !^Precedence: (list|bulk|junk)
* !^Auto-Submitted:
| <replaceable>/usr/local/bin/mapson</replaceable></screen>
      </informalexample>

      <para>In case you're wondering: The <literal>[0-9]</literal> string must
indeed be repeated exactly 32 times, because a cookie consists of 32 characters
in the range of <literal>a</literal> to <literal>f</literal> or
<literal>0</literal> to <literal>9</literal>. Some regular expression libraries
allow to shortcut this expression as <literal>[a-f0-9]{32}</literal>, but
apparently the one shipped with procmail is not one of them. At least on my
machines, I was not able to make that work.</para>

      <para>What this recipe does is to deliver any incoming mail that is
addressed to <literal>user+pass</literal> to the mailbox without any further
processing. I use this to make sure that mail aliased to me from
<literal>postmaster</literal> or <literal>root</literal> doesn't get stuck
somewhere. The next recipe pipes incoming confirmation mails into &mapson;. In
the request-for-confirmation template, the sender address is configurable. So
instead of using <literal>simons@example.org</literal> there, I put
<literal>simons+<varname>${MD5HASH}</varname>@example.org</literal> into the
From line, to make replies go to the special address. See <xref
linkend="reqmail-template"> for further details about how to customize the
request-for-confirmation template.</para>

      <para>The next recipe will direct any other mail that has an argument
around &mapson; before the last recipe finally invokes the program. Thus, if you
want to avoid sending mailing list postings through &mapson; -- and you
<emphasis>want to</emphasis> avoid that --, all you have to do is not to
subscribe your normal address to the list but
<literal>user+<replaceable>whatever</replaceable>@example.org</literal> and
&mapson; won't see it. It doesn't matter what you chose for
<replaceable>whatever</replaceable>, procmail will accept any string in this
configuration.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>Command Line Syntax</title>

    <para>&mapson understans several optional parameters on the command line,
which allow you to override the compiled-in default or the settings in the
config file. The standard Unix synopsis line is:</para>

    <blockquote>
      &synopsis;
    </blockquote>

    <para>Here is a list of all options together with a short description of
what the respective option does:</para>

    &cmdloptions;
  </sect1>

  <sect1>
    <title>The &mapson; Configuration File</title>
    &configfile;
  </sect1>

  <sect1 id="reqmail-template">
    <title>The Request-for-Confirmation File</title>

    <para>The request-for-confirmation mail is created by loading the configured
template file and exanding the variables contained in it. The result is then
piped into the command, you have configured as <varname>MTA</varname>. Please
note that &mapson; expects the file to be a valid RFC822 message! That means
that it contains a set of header lines and a mail body, the two parts being
separated by a blank line.</para>

    <para>Here is a short example of a request-for-confirmation template you
might use:</para>

    <informalexample>
      <screen>From: <replaceable>username@example.com</replaceable> (<replaceable>Real Name</replaceable>'s Anti<markup>-</markup>Spam<markup>-</markup>Tool)
To: ${ENVELOPE:<markup>-</markup>${RETURN_PATH:<markup>-</markup>${SENDER}}}
Subject: please confirm [${MD5HASH}]
Precedence: junk
Auto<markup>-</markup>Submitted: auto<markup>-</markup>generated
References: $MESSAGEID
In<markup>-</markup>Reply<markup>-</markup>To: $MESSAGEID

This is an automated request for confirmation in order to make
sure that the message quote below was actually sent by you. You
don't wanna know the details, trust me. Just press &lt;reply&gt;
and send me a mail back without changing that cookie in the subject
line, that's it. You will never have to do that again -- sorry for
the inconvenience!

Your mail was:

[ | ${HEADER[#]}] |
[${BODY[#]:+ | }${BODY[#]}]{0,5} | \[...\]</screen>
    </informalexample>

    <para>&mapson; will replace the variables you see in this example by the
actual values from the incoming mail and deliver the confirmation request. Don't
panic, there's a pretty good template included in the distribution (see <xref
linkend="deftmpl">) that you can use, you don't have to worry about the variable
stuff too much if you don't want to. For those who want to &hellip; Here is the
complete list of variables provided by &mapson; for this file:</para>

    <variablelist>
      <varlistentry>
        <term><varname>$MD5HASH</varname></term>
        <listitem>
          <para>&mapson; will calculate an MD5 checksum of the received mail and
make that result available in this variable. This string will also be used as
the filename of the mail in the spool directory, by the way. Your
request-for-confirmation template <emphasis>must</emphasis> contain this string
somewhere, or &mapson; won't be able to process the confirmation when it
arrives.</para>

          <para>A good idea is to place the cookie in the Subject of the mail,
because users are less likely to erase it there by accident. (Friendly euphemism
for <quote>stupidity</quote>.)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$ENVELOPE</varname></term>
        <listitem>
          <para>This variable contains the envelope of the incoming mail. The
<quote>envelope</quote> is the address that was given as the sender during the
SMTP dialog when the mail is transported. It's usually the only address that's
not entirely trivial to fake or mess up, so you should use this one whenever
possible to send the request for confirmation to.</para>

          <para>Unfortunately, the envelope is not available in the standard
RFC822 message format, but under Unix, it is customary to include it in the very
first <quote>From&blank;</quote> line. At least
<application>sendmail</application> does that.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$SENDER</varname></term>
        <listitem>
          <para>This variable will expand to the address stated in the message's
<quote>Sender:</quote> header.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$RETURN_PATH</varname></term>
        <listitem>
          <para>This variable will expand to the address stated in the message's
<quote>Return-Path:</quote> header.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$HEADER</varname></term>
        <listitem>
          <para>This variable contains the complete headers of the incoming
mail.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$BODY</varname></term>
        <listitem>
          <para>This variable contains the complete body of the incoming mail.
Be careful, this may be long!</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$MESSAGEID</varname></term>
        <listitem>
          <para>This variable contains the contents of the incoming mail's
<quote>Message-Id:</quote> header.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>In addition to those, the following arrays are provided:</para>

    <variablelist>
      <varlistentry>
        <term><varname>$HEADERLINES[]</varname></term>
        <listitem>
          <para>This array contains one text line of the message's header per
entry.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <variablelist>
      <varlistentry>
        <term><varname>$HEADER[]</varname></term>
        <listitem>
          <para>This array contains one of the message's header lines per entry.
A <quote>header line</quote> in this context means actually several text lines,
because RFC822 headers may span over multiple lines if the next line starts with
whitespace.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <variablelist>
      <varlistentry>
        <term><varname>$BODY[]</varname></term>
        <listitem>
          <para>This array contains one text line of the message's body per
entry.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  <sect1>
    <title>Expiring the Mail Spool</title>

    <para>to be written</para>
  </sect1>

  <sect1>
    <title>Importing Addresses From a Mail Archive</title>

    <para>Of course it would be unpolite to have &mapson; send out
requests for confirmation to people who you have been communicating
with you for months or years, just because you installed a new
tool. If you were wise enough to archive your old e-mails, there's a
simple way to avoid that happening: Import their addresses into
&mapson;'s database.</para>

    <para>Unfortunately, most mail readers archive old mails in one
single file: Each new mail is just appended at the end, just like the
mailbox format itself. Currently, &mapson; can not deal with those
files. The current version can import addresses only from an archive
where a each mail is stored in a separate file, like the archives
maintained by the <application>Gnus</application> software, that is
part of <application>Emacs</application>, for example.</para>

    <para>In this case, though, it's simple enough: Just start
&mapson; and give it the file names as parameters on the command line.
You might want to enable debugging by giving it the
<option>-d</option> flag, so that you can see what's going on:</para>

    <informalexample>
      <screen>simons@peti:~/mail-archive$ mapson -d *
1:
12:
    simons@peti.gmd.de................................. new
16:
    simons@peti.gmd.de................................. known
17:
    th@example.com..................................... new
    th@example.com..................................... known
    th@example.com..................................... known
19:
    bscw@cscwmail.example.org.......................... new
    manfred.bogen@gmd.example.org...................... new
53:
    pakhomenko@example.com............................. new
    pakhomenko@example.com............................. known
</screen>
    </informalexample>

    <para>Depending on the size of your mail archive, this may take a
while, but usually &mapson; is pretty quick.</para>

    <para>Once that's finished, you'll have a pretty good database to
start with, and it's highly unlikely that someone, who has been in
contact with you before, will be bothered with an
request-for-confirmation mail.</para>
  </sect1>

  <sect1>
    <title>What To Do If Something Does Not Work</title>

    <para>There's a chance that &mapson; isn't working the way you expect it --
especially in the current unfinished state of the program. Here's a short
description of how you can probably figure what's going wrong. The magic word is
<quote>log file</quote>. &mapson; logs pretty much everything it does to a file,
which is per default located at <filename>$HOME/.mapson/log</filename>.</para>

    <para>A typical set of messages found there may look like this:</para>

    <informalexample>
      <screen>debug: mapSoN verion 2.0-beta-2 starting up
debug: My configuration:
debug:     Mailbox            = '/var/spool/mail/'
debug:     ConfigFile         = '/home/<replaceable>user</replaceable>/.mapson/config'
debug:     SpoolDir           = '/home/<replaceable>user</replaceable>/.mapson/spool'
debug:     AddressDB          = '/home/<replaceable>user</replaceable>/.mapson/address-db'
debug:     ReqConfirmTemplate = '/home/<replaceable>user</replaceable>/.mapson/reqmail.template: \
    /usr/local/share/mapson/reqmail.template'
debug:     MTA                = '/usr/sbin/sendmail '-f&lt;&gt;' -i -t'
debug:     StrictRFCParser    = 'false'
debug:     PassIncorrectMails = 'true'
debug:     RuntimeErrorRC     = '75'
debug:     SyntaxErrorRC      = '65'
debug:     Debug              = 'true'
error: Runtime error while processing mail 'no-message-id': \
    Can't open address db '/home/<replaceable>user</replaceable>/.mapson/address-db' \
    for reading: No such file or directory</screen>
    </informalexample>

    <para>Please note that the backslashes in this example are not actually
there, they just denote added line breaks for the layout. In the real file,
these split lines are just one one long line.</para>

    <para>If you find that your copy of &mapson; does not log the proceedings in
this amount of detail, set the <varname>Debug</varname> directive in the
configuration file to <parameter>yes</parameter> or add the
<parameter>-d</parameter> parameter to the command line when calling
&mapson;.</para>

    <para>By looking at the log file, you can see what exactly &mapson; is doing
and why it's doing it. In the example shown above, it fails because of a file
permission error.</para>

    <para>Of course there are some reasons that may cause &mapson; to behave in
a way different from what you execpted that are not directly connected to the
&mapson; program itself. Here's a list of popular mistakes:</para>

    <itemizedlist>
      <listitem>
        <para>Check whether the mailbox file &mapson; uses to deliver passed
mails is correct! If it is not, you obviously won't see anything.</para>
      </listitem>
      <listitem>
        <para>Check whether &mapson; actually <emphasis>sees</emphasis> the
incoming mails it is supposed to. Especially when you are using
<application>procmail</application> to filter incoming e-mail, make sure that
the confirmation mails are passed to &mapson;. You can debug what
<application>procmail</application> is doing by adding the lines</para>

        <informalexample>
          <screen>VERBOSE=on
LOGFILE=$HOME/procmail.log</screen>
        </informalexample>

        <para>to your <filename>.procmailrc</filename> file. Then look at
<application>procmail</application>'s log file.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <appendix>
    <title>The Default Configuration</title>

    <para>The following configuration file shows the defaults compiled into
&mapson;, so if your config file looks like this, you can as well erase it
completely. The install process will install a sample configuration like this on
your machine as <filename>${sysconfdir}/config-sample</filename>. If you didn't
mess with the paths during the build, <varname>${sysconfdir}</varname> will be
<filename>/usr/local/share/mapson</filename>.</para>

    <screen>&defconfig;</screen>
  </appendix>

  <appendix id="deftmpl">
    <title>A Request-for-Confirmation Template Example</title>

    <para>The following file will be installed on your machine as
<filename>${datadir}/reqmail.template-sample</filename>. If you didn't mess with
the paths during the build, <varname>${datadir}</varname> will be
<filename>/usr/local/share/mapson</filename>.</para>

    <screen>&defreqmail;</screen>
  </appendix>

  <appendix>
    <title>License</title>
    &license;
  </appendix>

</article>

<!--
Local Variables:
mode: sgml
fill-column:80
End:
-->
