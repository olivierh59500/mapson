<!--
Local Variables:
mode: sgml
fill-column:80
End:
-->
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
<!ENTITY mapson "<application>mapSoN</application>">
<!ENTITY description SYSTEM "description.inc">
<!ENTITY building SYSTEM "building.inc">
<!ENTITY synopsis SYSTEM "synopsis.inc">
<!ENTITY cmdloptions SYSTEM "cmdloptions.inc">
<!ENTITY license SYSTEM "license.inc">
<!ENTITY defconfig SYSTEM "defconfig.inc">
<!ENTITY defreqmail SYSTEM "defreqmail.inc">
]>

<article lang="en">
  <articleinfo>
    <title>Incomplete &mapson; User Manual</title>
    <author>
      <firstname>Peter</firstname>
      <surname>Simons</surname>
      <affiliation>
        <address><email>simons@computer.org</email></address>
      </affiliation>
    </author>
  </articleinfo>

  <sect1>
    <title>Introduction</title>

    &description;

    <para>This manual describes how to compile, install, and configure &mapson;
in various setups.</para>
  </sect1>

  <sect1>
    <title>Building &mapson;</title>
    &building;
  </sect1>

  <sect1>
    <title>Command Line Syntax</title>

    <para>&mapson understans severel optional parameters an the
command line, which allow you to override the compiled-in default or
the settings in the config file. The standard Unix synopsis line
is:</para>

    <blockquote>
      &synopsis;
    </blockquote>

    <para>Here is a list of all options together with a short
description of what the respective option does:</para>

    &cmdloptions;
  </sect1>

  <sect1>
    <title>The &mapson; Configuration File</title>

    <para>The configuration file may contain the following directives:</para>

    <variablelist>
      <varlistentry>
        <term><literal>Mailbox</literal> <parameter>file</parameter></term>
        <listitem>
          <para>This directive sets the complete path of the mailbox file, where
&mapson; stores approved mails.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>SpoolDir</literal> <parameter>directory</parameter></term>
        <listitem>
          <para>This directive sets the complete path to the directory, in which
deferred mails will be spooled until a confirmation arrives for them.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>AddressDB</literal> <parameter>file</parameter></term>
        <listitem>
          <para>This directive sets the complete path of the file &mapson; uses
to store the "known" addresses.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ReqConfirmTemplate</literal> <parameter>file</parameter></term>
        <listitem>
          <para>This directive sets the complete path to the
request-for-confirmation template file &mapson; uses to generate the
request-for-confirmation mail sent to first-time originators.</para>

          <para>An arbitrary number of alternate paths can be
specified, if they're separated by colons, for example:</para>

          <informalexample>
            <screen>$HOME/.mapson/reqmail.template:$DATADIR/reqmail.template:&hellip;</screen>
          </informalexample>

          <para>In this setup, &mapson; would first try to load the
file <filename>$HOME/.mapson/reqmail.template</filename>. If that
failed, it would try <filename>$DATADIR/reqmail.template</filename>,
and so on, until one of the files can be loaded successfully.</para>

          <para>This is an extreme useful feature if you are a system
administrator who wishes to allow all users of the system to use
&mapson; without having to create a request-for-confirmation template
of their own: Configure &mapson; to load that request-for-confirmation
template first, that is located in the user's home directory. If this
file does not exist, then fall back to the system-wide file.</para>

          <para>In effect, that means that the user can simply use
&mapson; to filter his mail, and if he ever feels like it, he can
create a request-for-confirmantion template file of his own and it
will be preferred over the system-wide one.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>MTA</literal> <parameter>command</parameter></term>
        <listitem>
          <para>This directive sets the command &mapson will use to
send-out a request-for-confirmation mail. The actual mail will be
piped into the started process.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>PassIncorrectMails</literal> <parameter>boolean</parameter></term>
        <listitem>
          <para>When &mapson; parses the incoming mail's headers for
the addresses, it may detect syntax errors in the mail header, that do
not cause a fatal error, but that surely hint to the fact that this
mail was not created by an RFC822-conformant mail client.</para>

          <para>Many spam mails contain incorrect header lines, so you
may chose to have &mapson fail on <emphasis>any</emphasis> syntax
error -- even non-fatal ones. "Failing" means that &mapson; will abort
and return the return code configured below to the
<acronym>MTA</acronym>. Depending on the setting of the return code, the
MTA will then bounce the mail.</para>

          <para>The parameter given to this option is a boolean,
meaning that you may specify either <literal>yes</literal> or
<literal>no</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>StrictRFCParser</literal> <parameter>boolean</parameter></term>
        <listitem>
          <para>If you enable this option by specifying
<literal>yes</literal>, &mapson; will perform additional syntax checks
on the incoming mail, if you say <literal>no</literal>, it will check
only those headers that are needed for &mapson; to operate at
all.</para>

          <para>Enabling this option makes little sense unless you
disable the <symbol>PassIncorrectMails</symbol> option.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>RuntimeErrorRC</literal> <parameter>integer</parameter></term>
        <listitem>
          <para>This directive sets the return code &mapson; exits
with in case it had to abort with a run-time error. Possible run-time
errors are failure to open file, lack of available memory,
<abbrev>etc.</abbrev> &hellip;</para>

          <para>The default choice is "75", which
<application>sendmail</application> will interpret as a temporary
system error, so it will queue the mail and re-try.</para>

          <para>A valid return code is a positive integer up to
128.</para>
        </listitem>
      </varlistentry>
      <varlistentry>

        <term><literal>SyntaxErrorRC</literal> <parameter>integer</parameter></term>
        <listitem>
          <para>This directive sets the return code &mapson; exits
with in case it encountered a fatal syntax error in the e-mail. If
<symbol>PassIncorrectMails</symbol> is disabled, non-fatal syntax
errors will also cause &mapson; to abort with this return code.</para>

          <para>The default choice is "65", which
<application>sendmail</application> will interpret as a permanent
error that causes the mail to bounce.</para>

          <para>A valid return code is a positive integer up to
128.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>Debug</literal> <parameter>boolean</parameter></term>
        <listitem>
          <para>If you enable debugging messages by saying
<literal>yes</literal> here, &mapson; will log additional information
about its procssing of the mail. If you say <literal>no</literal>,
&mapson; will log only very few messages at all.</para>

          <para>Debugging is available only when the binary has been
compiled with the <symbol>DEBUG</symbol> symbol defined. Currently,
that is the default, though, so unless you exclicitely disabled it,
debugging will be available.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>In order to make the contents of the configuration file as
independent from the system's directory structure as possible,
&mapson; provides a set of environment variables, which are guaranteed
to be defined. You can use them anywhere in the data part of a
configuration directive, and you can use the usual manipulations on
them.</para>

    <para>Envirenment variables are looked-up case-sensitive, so
<varname>$home</varname> is not the same thing as
<varname>$HOME</varname>. This behavior is different in the
request-for-confirmation template, where you can spell the variables
upper- or lower-case as you wish. That's because the variables there
are not coming from the environmnet, but are &mapson;'s internal
variables. So be sure not to confuse that, because an undefined
variable in this file will cause &mapson; to abort with an
error.</para>

    <para>&mapson; will not overwrite already existing variables,
though! If your system defines, for example, the
<varname>$HOME</varname> variable, then you'll get the value from the
system's variable.</para>

    <para>Here is the complete list:</para>

    <variablelist>
      <varlistentry>
        <term><varname>$MAILBOXDIR</varname></term>
        <listitem>
          <para>This variable contains the complete path of directory,
in which the system's mailboxes are located, usually
<filename>/var/spool/mail</filename>. Please note that the value
provided here is the one determined at
<emphasis>compile-time</emphasis>, so if you changed your system's
installation and want to rely on this variable, you'll have to
re-compile.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$MTA</varname></term>
        <listitem>
          <para>This variable contains the path to the systems mail
transport agent. Please note, that this is only the path of the
executable -- for example <filename>/usr/sbin/sendmail</filename> --,
the variable does not contain the flags that must be passed to the
<acronym>MTA</acronym> in order to do something useful.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$DATADIR</varname></term>
        <listitem>
          <para>This variable contains the complete path of the
directory, which has been compiled into &mapson; as the directory
where read-only architecture-independent data should be stored. You
will, for example, find the system-wide request-for-confirmation
template file here.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$USER</varname></term>
        <listitem>
          <para>This variable contains the name of the user under
which &mapson; is running. Depending on your <acronym>MTA</acronym>,
this must not necessarily be the user who is receiving mail! If you're
using <application>sendmail</application>, though, you're on the
secure side.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$HOME</varname></term>
        <listitem>
          <para>This variable contains the complete path of
<varname>$USER</varname>'s home directory.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
  </sect1>

  <sect1>
    <title>The Request-for-Confirmation File</title>

    <para>The request-for-confirmation mail is created by loading the configured
template file and exanding the variables contained in it. The result is then
piped into the command, you have configured as <varname>MTA</varname>.</para>

    <para>The following variables are provided in the request-for-confirmation
mail template file:</para>

    <variablelist>
      <varlistentry>
        <term><varname>$md5hash</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$envelope</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$sender</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$return_path</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$header</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$body</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>$messageid</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>In addition to those, the following arrays are provided:</para>

    <variablelist>
      <varlistentry>
        <term><varname>$headerlines[]</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>

    <variablelist>
      <varlistentry>
        <term><varname>$header[]</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>

    <variablelist>
      <varlistentry>
        <term><varname>$body[]</varname></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  <sect1>
    <title>How to Activate &mapson;</title>

    <para>Before you can activate &mapson; you have to make sure that
all required directories exist and that all required files can be
created. &mapson; will try to create the address database file, for
instance, but the default setting is that this database is located at
<filename>$HOME/.mapon/address-db</filename>, and &mapson;
<emphasis>will not</emphasis> create the
<filename>$HOME/.mapson</filename> directory.</para>

    <para>The same applies to the mail spool directory, where &mapson;
stores those mails that need a confirmation before they are delivered.
The default location is <filename>$HOME/.mapson/spool</filename>, and
&mapson will create the spool directory itself, but it won't create
the <filename>$HOME/.mapson</filename> directory.</para>

    <para>The cut a long story short: Create the directory
<filename>.mapson</filename> in your home directory before you try to
use &mapson;. If you changed the configuration, though, the locations
may vary.</para>

    <para>Once that's out of the way, you need to create a template
file that &mapson; will use to generate the request-for-confirmation
mail. The installation process has created you a sample file for this
purpose to
<filename>/usr/local/share/mapson/reqmail.template-sample</filename>,
so thats probably a good starting point.</para>

    <para>Then, all that's left to do is to hook mapson into your mail
system so that incoming e-mails are no longer delivered to your
mailbox directly but are piped into &mapson;. How you can do this
depends on the setup you have. The following sections will give you
detailed instructions for the different scenarios.</para>

    <sect2>
      <title>Via <filename>.forward</filename></title>

      <para>If you're using a plain
<application>sendmail</application> installation, and don't have any
fancy local mailers like <application>procmail</application>
installed, you can activate &mapson; by writing an appropriate
pipe-command to the file <filename>.forward</filename> in your home
directory:</para>

      <blockquote>
        <programlisting>"|exec <replaceable>/usr/local/bin/mapson</replaceable>"</programlisting>
      </blockquote>

      <para>Apparently, on some systems the home directory must grant
execute-permission to "other" for the <acronym>MTA</acronym> to
evaluate that file. So if you created the
<filename>.forward</filename> file as shown above and still there's no
sign of any &mapson; activity, execute <userinput>chmod 711
$HOME</userinput> and try again.</para>

      <para>Another potential obstacle is that some
<application>sendmail</application> installation use the restricted
shell (<acronym>smrsh</acronym>) for the execution of the local
mailer. This shell will not allow users to execute arbitrary commands
in the <filename>.forward</filename> file. If your system uses the
smrsh, you must create a link from
<filename>/usr/local/bin/mapson</filename> to
<filename>/usr/adm/sm.bin/mapson</filename> in order to enable
&mapson;. (The paths may vary from system to system,
obviously.)</para>
    </sect2>

    <sect2>
      <title>Via <filename>.procmailrc</filename></title>

      <para>Most systems these days use
<application>procmail</application> to deliver local mail. That means,
that you can configure your local mailer by adding cryptic recipts in
an entirely undocumented syntax to the file
<filename>.procmailrc</filename> in your home directory.</para>

      <para>The good thing about <application>procmail</application>
is that it gives you way more control over which e-mail is going
where. For example, you don't want to pipe mail through &mapson; that
has been delivered to you via a mailing list: It would be really gross
to request confirmation for a mail from someone who doesn't even know
you and hasn't even mailed you -- all he did was to post on a mailing
list.</para>

      <para>Unfortunately, recognizing mail that came from a mailing
list is not an easy thing to do, but the following
<application>procmail</application> recipt should work pretty good:</para>

      <blockquote>
        <programlisting># Pipe anything, that is not a reply or comes from a mailing
# list, into mapson for approval.
#
:0 w
* !^(In-Reply-To|References|Message-Id):.*<replaceable>example.com</replaceable>
* !^Precedence: (list|bulk|junk)
* !^Auto-Submitted:
| <replaceable>/usr/local/mapson/bin/mapson</replaceable></programlisting>
      </blockquote>

      <para>Using <application>procmail</application>`s "argument"
feature, you can make this work even better, but that is still marked
TODO in this manual &hellip; Here are the recipts, nonetheless, in
case you think you know what you're doing.</para>

        <blockquote>
          <programlisting>ARGUMENT="$1"

# An argument of 'failsafe' will always by-pass all other
# rules to make sure that I have a reliably working address
# no matter what happens here.
#
:0
* ARGUMENT ?? failsafe
$DEFAULT

# Confirmation mails go into mapSoN.
# Note: Not all systems support that regular expression syntax!
#
:0
* ARGUMENT ?? [a-f0-9]{32}
| <replaceable>/usr/local/mapson/bin/mapson</replaceable>
:0 ec

# Anything that has such an argument is probably coming from
# a mailing list and should not go through mapSoN.
#
:0
* ARGUMENT ?? ..*
$DEFAULT</programlisting>
      </blockquote>
    </sect2>
  </sect1>

  <sect1>
    <title>Expiring the Mail Spool</title>

    <para>
  </sect1>

  <sect1>
    <title>Importing Addresses From a Mail Archive</title>

    <para>Of course it would be unpolite to have &mapson; send out
requests for confirmation to people who you have been communicating
with you for months or years, just because you installed a new
tool. If you were wise enough to archive your old e-mails, there's a
simple way to avoid that happening: Import their addresses into
&mapson;'s database.</para>

    <para>Unfortunately, most mail readers archive old mails in one
single file: Each new mail is just appended at the end, just like the
mailbox format itself. Currently, &mapson; can not deal with those
files. The current version can import addresses only from an archive
where a each mail is stored in a separate file, like the archives
maintained by the <application>Gnus</application> software, that is
part of <application>Emacs</application>, for example.</para>

    <para>In this case, though, it's simple enough: Just start
&mapson; and give it the file names as parameters on the command line.
You might want to enable debugging by giving it the
<option>-d</option> flag, so that you can see what's going on:</para>

    <informalexample>
      <screen>simons@peti:~/mail-archive$ mapson -d *
1:
12:
    simons@peti.gmd.de................................. new
16:
    simons@peti.gmd.de................................. known
17:
    th@example.com..................................... new
    th@example.com..................................... known
    th@example.com..................................... known
19:
    bscw@cscwmail.example.org.......................... new
    manfred.bogen@gmd.example.org...................... new
53:
    pakhomenko@example.com............................. new
    pakhomenko@example.com............................. known
</screen>
    </informalexample>

    <para>Depending on the size of your mail archive, this may take a
while, but usually &mapson; is pretty quick.</para>

    <para>Once that's finished, you'll have a pretty good database to
start with, and it's highly unlikely that someone, who has been in
contact with you before, will be bothered with an
request-for-confirmation mail.</para>
  </sect1>

  <appendix>
    <title>License</title>
    &license;
  </appendix>

  <appendix>
    <title>The Default Configuration</title>
    <programlisting>&defconfig;</programlisting>
  </appendix>

  <appendix>
    <title>A Request-for-Confirmation Template Example</title>
    <programlisting>&defreqmail;</programlisting>
  </appendix>

</article>
